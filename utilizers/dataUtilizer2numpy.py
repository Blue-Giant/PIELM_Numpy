import numpy as np
import scipy.stats.qmc as stqmc
import scipy.io


# load the data from matlab of .mat
def load_Matlab_data(filename=None):
    data = scipy.io.loadmat(filename, mat_dtype=True, struct_as_record=True)  # variable_names='CATC'
    return data


# Generate uniform mesh points for the inner of a 1D domain
def gene_1Dmesh_points2inner(num2point=100, variable_dim=1, region_l=0.0, region_r=0.0,  to_float=True,
                             float_type=np.float32, shuffle_uniform=False):
    assert variable_dim == 1
    grid = np.linspace(region_l, region_r, num2point + 1, endpoint=False)  # Generate the coordinate
    XYpoints = np.reshape(grid[1:num2point+1], newshape=[-1, 1])

    # assign the type of float for points
    if to_float:
        XYpoints = XYpoints.astype(dtype=float_type)

    if shuffle_uniform:
        np.random.shuffle(XYpoints)  # Multi-dimensional arrays are only shuffled along the first axis

    return XYpoints


# Generate random points within a 1D domain
def gene_1Drand_points2inner(num2point=100, variable_dim=1, region_l=0.0, region_r=0.0, to_float=True,
                             float_type=np.float32, eps=0.001, opt2rand='uniform', shuffle_uniform=True):
    assert variable_dim == 1
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for LatinHypercube()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x
        XYpoints = (region_r-region_l) * np.random.random(size=[num2point, 1]) + region_l
    elif str.lower(opt2rand) == 'lhs':
        sampler = stqmc.LatinHypercube(d=variable_dim)
        XYpoints = (region_r-region_l) * sampler.random(num2point) + region_l
    else:
        # Generate rand-points for x direction
        XYpoints = np.random.uniform(low=region_l + eps, high=region_r, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(XYpoints)  # Multi-dimensional arrays are only shuffled along the first axis

    if to_float:
        XYpoints = XYpoints.astype(dtype=float_type)

    return XYpoints


# Generate the boundary for 1D interval
def gene_1Dinterval2bd(num2point=100, variable_dim=1, region_l=0.0, region_r=0.0,  to_float=True,
                       float_type=np.float32):
    assert variable_dim == 1
    x_left_bd = np.ones([num2point, 1], dtype=float_type) * region_l
    x_right_bd = np.ones([num2point, 1], dtype=float_type) * region_r

    if to_float:
        x_left_bd = x_left_bd.astype(dtype=float_type)
        x_right_bd = x_right_bd.astype(dtype=float_type)

    return x_left_bd, x_right_bd


# Generate uniform mesh points for the inner of a 2D regular square(or rectangle) domain
def gene_2Dmesh_points2inner(num2mesh=100, variable_dim=2, region_l=0.0, region_r=0.0, region_b=0.0, region_t=0.0,
                             to_float=True, float_type=np.float32, shuffle_point=False):
    assert variable_dim == 2
    coord2x = np.linspace(region_l, region_r, num2mesh + 1, endpoint=False)  # Generate the coordinate for x direction
    coord2y = np.linspace(region_b, region_t, num2mesh + 1, endpoint=False)  # Generate the coordinate for y direction

    gridx = coord2x[1: num2mesh + 1]
    gridy = coord2y[1: num2mesh + 1]
    meshX, meshY = np.meshgrid(gridx, gridy)  # Construct the mesh points

    # reshaping the mesh points into vector-points
    XYpoints = np.concatenate((np.reshape(meshX, newshape=[-1, 1]), np.reshape(meshY, newshape=[-1, 1])), axis=-1)

    # assign the type of float for points
    if to_float:
        XYpoints = XYpoints.astype(dtype=float_type)

    if shuffle_point:
        np.random.shuffle(XYpoints)  # Multi-dimensional arrays are only shuffled along the first axis

    return XYpoints


# Generate random points within a 2D regular square(or rectangle) domain
def gene_2Drand_points2inner(num2point=100, variable_dim=2, region_l=0.0, region_r=0.0, region_b=0.0, region_t=0.0,
                             to_float=True, float_type=np.float32, eps=0.001, opt2rand='uniform', shuffle_uniform=True):
    assert variable_dim == 2
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_r-region_l) * np.random.random(size=[num2point, 1]) + region_l

        # Generate rand-points for y direction
        randy = (region_t-region_b) * np.random.random(size=[num2point, 1]) + region_b
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        randx = (region_r - region_l) * sampler2x.random(num2point) + region_l

        sampler2y = stqmc.LatinHypercube(d=1)
        randy = (region_t - region_b) * sampler2y.random(num2point) + region_b
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_l + eps, high=region_r, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_b + eps, high=region_t, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis

    XYpoints = np.concatenate((randx, randy), axis=-1)

    if to_float:
        XYpoints = XYpoints.astype(dtype=float_type)

    return XYpoints


# Generate mesh points on the boundary for a 2D regular square(or rectangle) domain
def gene_2Dmesh_points2bd(num2mesh=100, variable_dim=2, region_l=0.0, region_r=0.0, region_b=0.0, region_t=0.0,
                          to_float=True, float_type=np.float32, shuffle_point=False):
    assert variable_dim == 2
    # Generate the mesh coordinate for x direction
    gridx = np.linspace(region_l, region_r, num2mesh, endpoint=True)

    # Generate the mesh coordinate for y direction
    gridy = np.linspace(region_b, region_t, num2mesh, endpoint=True)

    # Construct the constant matrix of shape [n,2] for boundary values
    x_left_bd = np.ones([num2mesh, 2], dtype=float_type) * region_l
    x_right_bd = np.ones([num2mesh, 2], dtype=float_type) * region_r
    y_bottom_bd = np.ones([num2mesh, 2], dtype=float_type) * region_b
    y_top_bd = np.ones([num2mesh, 2], dtype=float_type) * region_t

    # On the left and right boundaries, the x is fixed and y is varied
    x_left_bd[:, 1] = gridy
    x_right_bd[:, 1] = gridy

    # On the bottom and top boundaries, the y is fixed and x is varied
    y_bottom_bd[:, 0] = gridx
    y_top_bd[:, 0] = gridx

    # assign the type of float for points
    if to_float:
        x_left_bd = x_left_bd.astype(dtype=float_type)
        x_right_bd = x_right_bd.astype(dtype=float_type)
        y_bottom_bd = y_bottom_bd.astype(dtype=float_type)
        y_top_bd = y_top_bd.astype(dtype=float_type)

    if shuffle_point:
        np.random.shuffle(x_left_bd)    # Multi-dimensional arrays are only shuffled along the first axis
        np.random.shuffle(x_right_bd)   # Multi-dimensional arrays are only shuffled along the first axis
        np.random.shuffle(y_bottom_bd)  # Multi-dimensional arrays are only shuffled along the first axis
        np.random.shuffle(y_top_bd)     # Multi-dimensional arrays are only shuffled along the first axis

    return x_left_bd, x_right_bd, y_bottom_bd, y_top_bd


# Generate random points on the boundary for a 2D regular square(or rectangle) domain
def gene_2Drand_points2bd(num2point=100, variable_dim=2, region_l=0.0, region_r=0.0, region_b=0.0, region_t=0.0,
                          to_float=True, float_type=np.float32, eps=0.001, opt2rand='random', shuffle_uniform=True):
    assert (int(variable_dim) == 2)
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        x_left_bd = (region_r - region_l) * np.random.random(size=[num2point, 2]) + region_l  # random 浮点数都是从[0,1)中随机。
        x_right_bd = (region_r - region_l) * np.random.random(size=[num2point, 2]) + region_l
        y_bottom_bd = (region_t - region_b) * np.random.random(size=[num2point, 2]) + region_b
        y_top_bd = (region_t - region_b) * np.random.random(size=[num2point, 2]) + region_b
    elif str.lower(opt2rand) == 'lhs':
        sampler2left = stqmc.LatinHypercube(d=2)
        sampler2right = stqmc.LatinHypercube(d=2)
        sampler2bottom = stqmc.LatinHypercube(d=2)
        sampler2top = stqmc.LatinHypercube(d=2)
        x_left_bd = (region_r - region_l) * sampler2left.random(num2point) + region_l  # random 浮点数都是从[0,1)中随机。
        x_right_bd = (region_r - region_l) * sampler2right.random(num2point) + region_l
        y_bottom_bd = (region_t - region_b) * sampler2bottom.random(num2point) + region_b
        y_top_bd = (region_t - region_b) * sampler2top.random(num2point) + region_b
    else:
        x_left_bd = np.random.uniform(low=region_l, high=region_r, size=[num2point, 2])  # uniform 浮点数都是从[a,b)中随机。
        x_right_bd = np.random.uniform(low=region_l, high=region_r, size=[num2point, 2])
        y_bottom_bd = np.random.uniform(low=region_b, high=region_t, size=[num2point, 2])
        y_top_bd = np.random.uniform(low=region_b, high=region_t, size=[num2point, 2])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(x_left_bd)
            np.random.shuffle(x_right_bd)
            np.random.shuffle(y_bottom_bd)
            np.random.shuffle(y_top_bd)

    for ii in range(num2point):
        x_left_bd[ii, 0] = region_l
        x_right_bd[ii, 0] = region_r
        y_bottom_bd[ii, 1] = region_b
        y_top_bd[ii, 1] = region_t

    if to_float:
        x_left_bd = x_left_bd.astype(dtype=float_type)
        x_right_bd = x_right_bd.astype(dtype=float_type)
        y_bottom_bd = y_bottom_bd.astype(dtype=float_type)
        y_top_bd = y_top_bd.astype(dtype=float_type)

    return x_left_bd, x_right_bd, y_bottom_bd, y_top_bd


# Generate uniform mesh points and rand points for the inner of a 2D regular square(or rectangle) domain
def gene_mesh_gene_rand_2Dinner(num2mesh=2, num2point=100, variable_dim=2, region_l=0.0, region_r=0.0, region_b=0.0,
                                region_t=0.0, to_float=True, float_type=np.float32, eps=0.001, opt2rand='uniform',
                                shuffle_uniform=True, shuffle_point=False):
    assert variable_dim == 2
    coord2x = np.linspace(region_l, region_r, num2mesh + 1, endpoint=False)  # Generate the coordinate for x direction
    coord2y = np.linspace(region_b, region_t, num2mesh + 1, endpoint=False)  # Generate the coordinate for y direction

    gridx = coord2x[1: num2mesh + 1]
    gridy = coord2y[1: num2mesh + 1]
    meshX, meshY = np.meshgrid(gridx, gridy)  # Construct the mesh points

    # reshaping the mesh points into vector-points
    xy_mesh = np.concatenate((np.reshape(meshX, newshape=[-1, 1]), np.reshape(meshY, newshape=[-1, 1])), axis=-1)

    if to_float:
        xy_mesh = xy_mesh.astype(dtype=float_type)

    assert variable_dim == 2
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_r - region_l) * np.random.random(size=[num2point, 1]) + region_l

        # Generate rand-points for y direction
        randy = (region_t - region_b) * np.random.random(size=[num2point, 1]) + region_b
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        randx = (region_r - region_l) * sampler2x.random(num2point) + region_l

        sampler2y = stqmc.LatinHypercube(d=1)
        randy = (region_t - region_b) * sampler2y.random(num2point) + region_b
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_l + eps, high=region_r, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_b + eps, high=region_t, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis

    xy_rand = np.concatenate((randx, randy), axis=-1)
    if to_float:
        xy_rand = xy_rand.astype(dtype=float_type)

    XY_Point = np.concatenate([xy_mesh, xy_rand], axis=0)
    if shuffle_point:
        np.random.shuffle(XY_Point)
    return (XY_Point, xy_mesh)


# Load uniform mesh points and generate rand points for the inner of a 2D regular square(or rectangle) domain
def load_mesh_gene_rand_2Dinner(path2file=None, num2mesh=2, num2point=100, variable_dim=2, region_l=0.0,
                                region_r=0.0, region_b=0.0, region_t=0.0, to_float=True, float_type=np.float32,
                                eps=0.001, opt2rand='uniform', shuffle_uniform=True, shuffle_point=False):
    test_meshXY_file = path2file + str('testXY') + str(num2mesh) + str('.mat')
    mesh_points = load_Matlab_data(test_meshXY_file)
    mesh_XY = mesh_points['XY']
    shape2XY = np.shape(mesh_XY)
    assert (len(shape2XY) == 2)
    if shape2XY[0] == 2:
        xy_mesh = np.transpose(mesh_XY, (1, 0))
    else:
        xy_mesh = mesh_XY

    if to_float:
        xy_mesh = xy_mesh.astype(dtype=float_type)

    assert variable_dim == 2
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_r - region_l) * np.random.random(size=[num2point, 1]) + region_l

        # Generate rand-points for y direction
        randy = (region_t - region_b) * np.random.random(size=[num2point, 1]) + region_b
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        randx = (region_r - region_l) * sampler2x.random(num2point) + region_l

        sampler2y = stqmc.LatinHypercube(d=1)
        randy = (region_t - region_b) * sampler2y.random(num2point) + region_b
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_l + eps, high=region_r, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_b + eps, high=region_t, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis

    xy_rand = np.concatenate((randx, randy), axis=-1)
    if to_float:
        xy_rand = xy_rand.astype(dtype=float_type)

    XY_Point = np.concatenate([xy_mesh, xy_rand], axis=0)
    if shuffle_point:
        np.random.shuffle(XY_Point)
    return (XY_Point, xy_mesh)


# Generate uniform mesh points for the inner of a 3D regular domain
def gene_3Dmesh_points2inner(num2mesh=10, variable_dim=3, region_left=0.0, region_right=0.0, region_behind=0.0,
                             region_front=0.0, region_bottom=0.0,  region_top=0.0, to_float=True, float_type=np.float32,
                             shuffle_point=False):
    assert variable_dim == 3
    # Generate the coordinate for x with left bd
    coord2x = np.linspace(region_left, region_right, num2mesh + 1, endpoint=False)

    # Generate the coordinate for y with left bd
    coord2y = np.linspace(region_behind, region_front, num2mesh + 1, endpoint=False)

    # Generate the coordinate for z with left bd
    coord2z = np.linspace(region_bottom, region_top, num2mesh + 1, endpoint=False)

    gridx = coord2x[1: num2mesh + 1]   # obtain the inner coordinates to x
    gridy = coord2y[1: num2mesh + 1]   # obtain the inner coordinates to y
    gridz = coord2z[1: num2mesh + 1]   # obtain the inner coordinates to z
    meshX, meshY, meshZ = np.meshgrid(gridx, gridy, gridz)  # Construct the mesh points

    # reshaping the mesh points into vector-points
    XYpoints = np.concatenate((np.reshape(meshX, newshape=[-1, 1]), np.reshape(meshY, newshape=[-1, 1]),
                               np.reshape(meshZ, newshape=[-1, 1])), axis=-1)

    # assign the type of float for points
    if to_float:
        XYpoints = XYpoints.astype(dtype=float_type)

    if shuffle_point:
        np.random.shuffle(XYpoints)  # Multi-dimensional arrays are only shuffled along the first axis

    return XYpoints


# Generate random points within a 2D regular square(or rectangle) domain
def gene_3Drand_points2inner(num2point=100, variable_dim=3, region_left=0.0, region_right=0.0, region_behind=0.0,
                             region_front=0.0, region_bottom=0.0,  region_top=0.0, to_float=True, float_type=np.float32,
                             eps=0.001, opt2rand='uniform', shuffle_uniform=True):
    assert variable_dim == 2
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_right-region_left) * np.random.random(size=[num2point, 1]) + region_left

        # Generate rand-points for y direction
        randy = (region_front-region_behind) * np.random.random(size=[num2point, 1]) + region_behind

        # Generate rand-points for y direction
        randz = (region_top - region_bottom) * np.random.random(size=[num2point, 1]) + region_bottom
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        sampler2y = stqmc.LatinHypercube(d=1)
        sampler2z = stqmc.LatinHypercube(d=1)

        # Generate rand-points for x direction
        randx = (region_right-region_left) * sampler2x.random(num2point) + region_left

        # Generate rand-points for y direction
        randy = (region_front-region_behind) * sampler2y.random(num2point) + region_behind

        # Generate rand-points for y direction
        randz = (region_top - region_bottom) * sampler2z.random(num2point) + region_bottom
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_left + eps, high=region_right, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_behind + eps, high=region_front, size=[num2point, 1])

        # Generate rand-points for y direction
        randz = np.random.uniform(low=region_bottom + eps, high=region_top, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randz)  # Multi-dimensional arrays are only shuffled along the first axis

    XYZpoints = np.concatenate((randx, randy, randz), axis=-1)

    if to_float:
        XYZpoints = XYZpoints.astype(dtype=float_type)

    return XYZpoints


# Load uniform mesh points and generate rand points for the inner of a 3D domain
def load_mesh_gene_rand_3Dinner(path2file=None, mesh_number=3, num2point=100, variable_dim=2, region_left=0.0,
                                region_right=0.0, region_bottom=0.0, region_top=0.0, region_front=0.0,
                                region_behind=0.0, to_float=True, float_type=np.float32, eps=0.001, opt2rand='uniform',
                                shuffle_uniform=True, shuffle_point=False):
    test_meshXY_file = path2file + str('testXYZ') + str(mesh_number) + str('.mat')
    mesh_points = load_Matlab_data(test_meshXY_file)
    mesh_XYZ = mesh_points['XYZ']
    shape2XYZ = np.shape(mesh_XYZ)
    assert (len(shape2XYZ) == 2)
    if shape2XYZ[0] == 3:
        xyz_mesh = np.transpose(mesh_XYZ, (1, 0))
    else:
        xyz_mesh = mesh_XYZ

    if to_float:
        xyz_mesh = xyz_mesh.astype(dtype=float_type)

    assert variable_dim == 3
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_right - region_left) * np.random.rand(num2point, 1) + region_left

        # Generate rand-points for y direction
        randy = (region_front - region_behind) * np.random.rand(num2point, 1) + region_behind

        # Generate rand-points for z direction
        randz = (region_top - region_bottom) * np.random.rand(num2point, 1) + region_bottom
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        sampler2y = stqmc.LatinHypercube(d=1)
        sampler2z = stqmc.LatinHypercube(d=1)

        # Generate rand-points for x direction
        randx = (region_right - region_left) * sampler2x.random(num2point) + region_left

        # Generate rand-points for y direction
        randy = (region_front - region_behind) * sampler2y.random(num2point) + region_behind

        # Generate rand-points for y direction
        randz = (region_top - region_bottom) * sampler2z.random(num2point) + region_bottom
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_left + eps, high=region_right, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_behind + eps, high=region_front, size=[num2point, 1])

        # Generate rand-points for z direction
        randz = np.random.uniform(low=region_bottom + eps, high=region_top, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randz)  # Multi-dimensional arrays are only shuffled along the first axis

    xyz_rand = np.concatenate((randx, randy, randz), axis=-1)

    if to_float:
        xyz_rand = xyz_rand.astype(dtype=float_type)

    XYZ = np.concatenate([xyz_mesh, xyz_rand], axis=0)
    if shuffle_point:
        np.random.shuffle(XYZ)
    return (XYZ, xyz_mesh)


# Generate uniform mesh points and rand points for the inner of a 3D regular domain
def gene_mesh_gene_rand_3Dinner(num2mesh=3, num2point=100, variable_dim=2, region_left=0.0,
                                region_right=0.0, region_bottom=0.0, region_top=0.0, region_front=0.0,
                                region_behind=0.0, to_float=True, float_type=np.float32, eps=0.001, opt2rand='uniform',
                                shuffle_uniform=True, shuffle_point=False):
    assert variable_dim == 3
    # Generate the coordinate for x with left bd
    coord2x = np.linspace(region_left, region_right, num2mesh + 1, endpoint=False)

    # Generate the coordinate for y with left bd
    coord2y = np.linspace(region_behind, region_front, num2mesh + 1, endpoint=False)

    # Generate the coordinate for z with left bd
    coord2z = np.linspace(region_bottom, region_top, num2mesh + 1, endpoint=False)

    gridx = coord2x[1: num2mesh + 1]  # obtain the inner coordinates to x
    gridy = coord2y[1: num2mesh + 1]  # obtain the inner coordinates to y
    gridz = coord2z[1: num2mesh + 1]  # obtain the inner coordinates to z
    meshX, meshY, meshZ = np.meshgrid(gridx, gridy, gridz)  # Construct the mesh points

    # reshaping the mesh points into vector-points
    XYpoints = np.concatenate((np.reshape(meshX, newshape=[-1, 1]), np.reshape(meshY, newshape=[-1, 1]),
                               np.reshape(meshZ, newshape=[-1, 1])), axis=-1)

    if to_float:
        xyz_mesh = XYpoints.astype(dtype=float_type)

    assert variable_dim == 3
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_right - region_left) * np.random.rand(num2point, 1) + region_left

        # Generate rand-points for y direction
        randy = (region_front - region_behind) * np.random.rand(num2point, 1) + region_behind

        # Generate rand-points for z direction
        randz = (region_top - region_bottom) * np.random.rand(num2point, 1) + region_bottom
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        sampler2y = stqmc.LatinHypercube(d=1)
        sampler2z = stqmc.LatinHypercube(d=1)

        # Generate rand-points for x direction
        randx = (region_right - region_left) * sampler2x.random(num2point) + region_left

        # Generate rand-points for y direction
        randy = (region_front - region_behind) * sampler2y.random(num2point) + region_behind

        # Generate rand-points for y direction
        randz = (region_top - region_bottom) * sampler2z.random(num2point) + region_bottom
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_left + eps, high=region_right, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_behind + eps, high=region_front, size=[num2point, 1])

        # Generate rand-points for z direction
        randz = np.random.uniform(low=region_bottom + eps, high=region_top, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randz)  # Multi-dimensional arrays are only shuffled along the first axis

    xyz_rand = np.concatenate((randx, randy, randz), axis=-1)

    if to_float:
        xyz_rand = xyz_rand.astype(dtype=float_type)

    XYZ = np.concatenate([xyz_mesh, xyz_rand], axis=0)
    if shuffle_point:
        np.random.shuffle(XYZ)
    return (XYZ, xyz_mesh)


# Generate uniform mesh points with fixed axis and rand points for the inner of a 3D regular domain
def gene_fixed_axis_mesh_and_rand_3Dinner(num2mesh=3, num2point=100, variable_dim=2, fixed_axis='x', value2axis=0.5,
                                          region_left=0.0, region_right=0.0, region_bottom=0.0, region_top=0.0,
                                          region_front=0.0, region_behind=0.0, to_float=True, float_type=np.float32,
                                          eps=0.001, opt2rand='uniform', shuffle_uniform=True, shuffle_point=False):
    assert variable_dim == 3
    # Generate the coordinate for x with left bd
    coord2x = np.linspace(region_left, region_right, num2mesh + 1, endpoint=False)

    # Generate the coordinate for y with left bd
    coord2y = np.linspace(region_behind, region_front, num2mesh + 1, endpoint=False)

    # Generate the coordinate for z with left bd
    coord2z = np.linspace(region_bottom, region_top, num2mesh + 1, endpoint=False)

    gridx = coord2x[1: num2mesh + 1]  # obtain the inner coordinates to x
    gridy = coord2y[1: num2mesh + 1]  # obtain the inner coordinates to y
    gridz = coord2z[1: num2mesh + 1]  # obtain the inner coordinates to z
    meshX, meshY, meshZ = np.meshgrid(gridx, gridy, gridz)  # Construct the mesh points

    if str.lower(fixed_axis) == 'x':
        fixed_x = np.ones_like(size=[num2mesh*num2mesh, 1])*value2axis
        # reshaping the mesh points into vector-points
        XYpoints = np.concatenate((fixed_x, np.reshape(meshY, newshape=[-1, 1]), np.reshape(meshZ, newshape=[-1, 1])),
                                  axis=-1)
    elif str.lower(fixed_axis) == 'y':
        fixed_y = np.ones_like(size=[num2mesh*num2mesh, 1])*value2axis
        # reshaping the mesh points into vector-points
        XYpoints = np.concatenate((np.reshape(meshX, newshape=[-1, 1]), fixed_y, np.reshape(meshZ, newshape=[-1, 1])),
                                  axis=-1)
    elif str.lower(fixed_axis) == 'z':
        fixed_z = np.ones_like(size=[num2mesh*num2mesh, 1])*value2axis
        # reshaping the mesh points into vector-points
        XYpoints = np.concatenate((np.reshape(meshX, newshape=[-1, 1]), np.reshape(meshY, newshape=[-1, 1]), fixed_z),
                                  axis=-1)

    if to_float:
        xyz_mesh = XYpoints.astype(dtype=float_type)

    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        # Generate rand-points for x direction
        randx = (region_right - region_left) * np.random.rand(num2point, 1) + region_left

        # Generate rand-points for y direction
        randy = (region_front - region_behind) * np.random.rand(num2point, 1) + region_behind

        # Generate rand-points for z direction
        randz = (region_top - region_bottom) * np.random.rand(num2point, 1) + region_bottom
    elif str.lower(opt2rand) == 'lhs':
        sampler2x = stqmc.LatinHypercube(d=1)
        sampler2y = stqmc.LatinHypercube(d=1)
        sampler2z = stqmc.LatinHypercube(d=1)

        # Generate rand-points for x direction
        randx = (region_right - region_left) * sampler2x.random(num2point) + region_left

        # Generate rand-points for y direction
        randy = (region_front - region_behind) * sampler2y.random(num2point) + region_behind

        # Generate rand-points for y direction
        randz = (region_top - region_bottom) * sampler2z.random(num2point) + region_bottom
    else:
        # Generate rand-points for x direction
        randx = np.random.uniform(low=region_left + eps, high=region_right, size=[num2point, 1])

        # Generate rand-points for y direction
        randy = np.random.uniform(low=region_behind + eps, high=region_front, size=[num2point, 1])

        # Generate rand-points for z direction
        randz = np.random.uniform(low=region_bottom + eps, high=region_top, size=[num2point, 1])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(randx)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randy)  # Multi-dimensional arrays are only shuffled along the first axis
            np.random.shuffle(randz)  # Multi-dimensional arrays are only shuffled along the first axis

    xyz_rand = np.concatenate((randx, randy, randz), axis=-1)

    if to_float:
        xyz_rand = xyz_rand.astype(dtype=float_type)

    XYZ = np.concatenate([xyz_mesh, xyz_rand], axis=0)
    if shuffle_point:
        np.random.shuffle(XYZ)
    return (XYZ, xyz_mesh)


# Generate random points on the boundary for a 2D regular square(or rectangle) domain
def gene_3Drand_points2bd(num2point=100, variable_dim=3, region_left=0.0, region_right=1.0, region_behind=0.0,
                          region_front=1.0, region_bottom=0.0, region_top=1.0, to_float=True, float_type=np.float32,
                          eps=0.001, opt2rand='random', shuffle_uniform=True):
    assert (int(variable_dim) == 3)
    # TODO: How to generate randomly the points within (0,1), rather than [0,1) for np.random.random()?
    if str.lower(opt2rand) == 'random':
        x_left_bd = (region_right - region_left) * np.random.random(size=[num2point, 3]) + region_left  # random 浮点数都是从[0,1)中随机。
        x_right_bd = (region_right - region_left) * np.random.random(size=[num2point, 3]) + region_left

        y_behind_bd = (region_front - region_behind) * np.random.random(size=[num2point, 3]) + region_behind
        y_front_bd = (region_front - region_behind) * np.random.random(size=[num2point, 3]) + region_behind

        z_bottom_bd = (region_top - region_bottom) * np.random.random(size=[num2point, 3]) + region_bottom
        z_top_bd = (region_top - region_bottom) * np.random.random(size=[num2point, 3]) + region_bottom
    elif str.lower(opt2rand) == 'lhs':
        sampler2left = stqmc.LatinHypercube(d=3)
        sampler2right = stqmc.LatinHypercube(d=3)

        sampler2front = stqmc.LatinHypercube(d=3)
        sampler2behind = stqmc.LatinHypercube(d=3)

        sampler2bottom = stqmc.LatinHypercube(d=3)
        sampler2top = stqmc.LatinHypercube(d=3)

        x_left_bd = (region_right - region_left) * sampler2left.random(num2point) + region_left  # random 浮点数都是从[0,1)中随机。
        x_right_bd = (region_right - region_left) * sampler2right.random(num2point) + region_left

        y_behind_bd = (region_front - region_behind) * sampler2front.random(num2point) + region_behind
        y_front_bd = (region_front - region_behind) * sampler2behind.random(num2point) + region_behind

        z_bottom_bd = (region_top - region_bottom) * sampler2bottom.random(num2point) + region_bottom
        z_top_bd = (region_top - region_bottom) * sampler2top.random(num2point) + region_bottom
    else:
        x_left_bd = np.random.uniform(low=region_left, high=region_right, size=[num2point, 3])  # uniform 浮点数都是从[a,b)中随机。
        x_right_bd = np.random.uniform(low=region_left, high=region_right, size=[num2point, 3])

        y_behind_bd = np.random.uniform(low=region_behind, high=region_front, size=[num2point, 3])
        y_front_bd = np.random.uniform(low=region_behind, high=region_front, size=[num2point, 3])

        z_bottom_bd = np.random.uniform(low=region_bottom, high=region_top, size=[num2point, 3])
        z_top_bd = np.random.uniform(low=region_bottom, high=region_top, size=[num2point, 3])

        # the point randomly generated by uniform distribution need be shuffled
        if shuffle_uniform:
            np.random.shuffle(x_left_bd)
            np.random.shuffle(x_right_bd)

            np.random.shuffle(y_behind_bd)
            np.random.shuffle(y_front_bd)

            np.random.shuffle(z_bottom_bd)
            np.random.shuffle(z_top_bd)

    for ii in range(num2point):
        x_left_bd[ii, 0] = region_left
        x_right_bd[ii, 0] = region_right

        y_behind_bd[ii, 1] = region_behind
        y_front_bd[ii, 1] = region_front

        z_bottom_bd[ii, 2] = region_bottom
        z_top_bd[ii, 2] = region_top

    if to_float:
        x_left_bd = x_left_bd.astype(dtype=float_type)
        x_right_bd = x_right_bd.astype(dtype=float_type)

        y_behind_bd = y_behind_bd.astype(dtype=float_type)
        y_front_bd = y_front_bd.astype(dtype=float_type)

        z_bottom_bd = z_bottom_bd.astype(dtype=float_type)
        z_top_bd = z_top_bd.astype(dtype=float_type)

    return x_left_bd, x_right_bd, y_behind_bd, y_front_bd, z_bottom_bd, z_top_bd


def gene_2D_rand_test():
    point_num = 100
    dim = 2
    left_bottom = 0.0
    rght_top = 1.0
    rand_opt = 'lhs'
    xy = gene_2Drand_points2inner(num2point=point_num, variable_dim=dim, region_l=left_bottom, region_r=rght_top,
                                  region_b=left_bottom, region_t=rght_top, to_float=True, float_type=np.float32,
                                  eps=0.001, opt2rand=rand_opt)
    print('!!!!!!')


def gene_mesh_gene_rand_test():
    num = 100
    dim = 2
    left_bottom = 0.0
    rght_top = 1.0
    rand_opt = 'uniform'
    xy = gene_mesh_gene_rand_2Dinner(num2mesh=5, num2point=num, variable_dim=dim, region_l=left_bottom,
                                     region_r=rght_top, region_b=left_bottom, region_t=rght_top, to_float=True,
                                     float_type=np.float32, eps=0.001, opt2rand=rand_opt)
    print('!!!!!!')


def gene_3D_mesh_test():
    mesh_num = 10
    dim = 3
    left_bottom = 0.0
    rght_top = 1.0
    rand_opt = 'uniform'
    xyz = gene_3Dmesh_points2inner(num2mesh=mesh_num, variable_dim=dim, region_left=left_bottom, region_right=rght_top,
                                   region_behind=left_bottom, region_front=rght_top, region_bottom=left_bottom,
                                   region_top=rght_top, to_float=True, float_type=np.float32, shuffle_point=False)

    print('!!!!!!')


if __name__ == "__main__":
    gene_2D_rand_test()
    # gene_mesh_gene_rand_test()
    # gene_3D_mesh_test()